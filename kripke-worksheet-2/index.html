<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kripke Worksheet 2 (wireframe)</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
      color: #111827;
    }
    #layout {
      display: grid;
      grid-template-columns: 260px minmax(0, 1fr);
      height: 100vh;
    }
    aside {
      border-right: 1px solid #e5e7eb;
      background: #111827;
      color: #e5e7eb;
      padding: 1rem;
      overflow-y: auto;
    }
    .problem-button {
      width: 100%;
      text-align: left;
      padding: 0.4rem 0.6rem;
      border-radius: 0.375rem;
      border: none;
      margin-bottom: 0.3rem;
      background: #1f2937;
      color: inherit;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .problem-button.active { background: #2563eb; }
    main { padding: 1rem 1.25rem; overflow-y: auto; }
    #problem-title { margin: 0 0 0.25rem; }
    .constraint-list { padding-left: 1.2rem; font-size: 0.95rem; }
    .note { background: #fef3c7; color: #92400e; padding: 0.6rem 0.75rem; border-radius: 0.5rem; margin: 0.75rem 0; }
    .check-button { margin-top: 0.75rem; padding: 0.5rem 0.9rem; border-radius: 999px; border: none; background: #16a34a; color: white; font-weight: 600; cursor: pointer; font-size: 0.9rem; }
    #result { margin-top: 0.75rem; background: #111827; color: #e5e7eb; padding: 0.75rem; border-radius: 0.5rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85rem; white-space: pre-wrap; }
    #playground-panel { margin-top: 1.25rem; background: #ffffff; border-radius: 0.75rem; border: 1px solid #e5e7eb; overflow: hidden; }
    #playground-header { padding: 0.5rem 0.75rem; border-bottom: 1px solid #e5e7eb; font-size: 0.9rem; background: #f9fafb; }
    #playground-frame { border: none; width: 100%; height: 700px; }
  </style>
</head>
<body>
<div id="layout">
  <aside>
    <h2>Problems</h2>
    <div id="problem-list"></div>
  </aside>
  <main>
    <h1 id="problem-title">Kripke Worksheet 2</h1>
    <p class="note">
      This worksheet now checks both the truth constraints and the required frame
      properties (reflexive, symmetric, transitive) for the listed modal logic.
    </p>
    <div id="problem-description"></div>
    <h3>Constraints to satisfy at w₀</h3>
    <ul id="constraint-list" class="constraint-list"></ul>
    <button class="check-button" onclick="checkCurrentProblem()">Check current model</button>
    <div id="result"></div>
    <section id="playground-panel">
      <div id="playground-header">Build a model for the active problem, then click “Check current model”.</div>
      <iframe id="playground-frame" src="../kripke-worksheet/modallogic/index.html" title="Modal Logic Playground"></iframe>
    </section>
  </main>
</div>

<script src="../kripke-worksheet/MPL.js"></script>
<script src="../kripke-worksheet/formula-parser.min.js"></script>
<script src="accessibility-utils.js"></script>
<script>
  const problems = [
    {
      id: "T1",
      title: "T: []P ⊭ [][]P",
      frame: "T (reflexive only)",
      description: "Make []P true and [][]P false at w₀ while keeping accessibility reflexive.",
      constraints: [
        { type: "truth", world: 0, formula: "[]P", expected: true },
        { type: "truth", world: 0, formula: "[][]P", expected: false },
        { type: "relation", property: "reflexive", expected: true },
      ],
    },
    {
      id: "T2",
      title: "T: <>P ⊭ []<>P",
      frame: "T (reflexive only)",
      description: "Make <>P true and []<>P false at w₀ while keeping accessibility reflexive.",
      constraints: [
        { type: "truth", world: 0, formula: "<>P", expected: true },
        { type: "truth", world: 0, formula: "[]<>P", expected: false },
        { type: "relation", property: "reflexive", expected: true },
      ],
    },
    {
      id: "T3",
      title: "T: []<><>P ⊭ <>P",
      frame: "T (reflexive only)",
      description: "Make []<><>P true and <>P false at w₀ while keeping accessibility reflexive.",
      constraints: [
        { type: "truth", world: 0, formula: "[]<><>P", expected: true },
        { type: "truth", world: 0, formula: "<>P", expected: false },
        { type: "relation", property: "reflexive", expected: true },
      ],
    },
    {
      id: "S41",
      title: "S4: <>[]P ⊭ []P",
      frame: "S4 (reflexive + transitive)",
      description: "Make <>[]P true and []P false at w₀ while accessibility stays reflexive and transitive.",
      constraints: [
        { type: "truth", world: 0, formula: "<>[]P", expected: true },
        { type: "truth", world: 0, formula: "[]P", expected: false },
        { type: "relation", property: "reflexive", expected: true },
        { type: "relation", property: "transitive", expected: true },
      ],
    },
    {
      id: "S42",
      title: "S4: <>P ⊭ []<>P",
      frame: "S4 (reflexive + transitive)",
      description: "Make <>P true and []<>P false at w₀ while accessibility stays reflexive and transitive.",
      constraints: [
        { type: "truth", world: 0, formula: "<>P", expected: true },
        { type: "truth", world: 0, formula: "[]<>P", expected: false },
        { type: "relation", property: "reflexive", expected: true },
        { type: "relation", property: "transitive", expected: true },
      ],
    },
    {
      id: "S51",
      title: "S5: [] (P v Q), ~[]P ⊭ []Q",
      frame: "S5 (reflexive + symmetric + transitive)",
      description: "Make [](P v Q) and ~[]P true while []Q is false at w₀, using a reflexive, symmetric, and transitive frame. (Error text tip: sometimes inclusive or is written as "|" rather than "v")",
      constraints: [
        { type: "truth", world: 0, formula: "[](P | Q)", expected: true },
        { type: "truth", world: 0, formula: "~[]P", expected: true },
        { type: "truth", world: 0, formula: "[]Q", expected: false },
        { type: "relation", property: "reflexive", expected: true },
        { type: "relation", property: "symmetric", expected: true },
        { type: "relation", property: "transitive", expected: true },
      ],
    },
    {
      id: "S52",
      title: "S5: []P -> []Q ⊭ [](P -> Q)",
      frame: "S5 (reflexive + symmetric + transitive)",
      description: "Make ([]P -> []Q) true while [](P -> Q) is false at w₀, using a reflexive, symmetric, and transitive frame.",
      constraints: [
        { type: "truth", world: 0, formula: "([]P -> []Q)", expected: true },
        { type: "truth", world: 0, formula: "[](P -> Q)", expected: false },
        { type: "relation", property: "reflexive", expected: true },
        { type: "relation", property: "symmetric", expected: true },
        { type: "relation", property: "transitive", expected: true },
      ],
    },
    {
      id: "Diag14",
      title: "Diagnosis: []<>P ⊢ <>P",
      frame: "Find the strongest logic where this fails.",
      description: "Build a countermodel showing []<>P does not entail <>P. We report truth values but do not mark success.",
      diagnostic: true,
      constraints: [
        { type: "truth", world: 0, formula: "[]<>P", expected: true },
        { type: "truth", world: 0, formula: "<>P", expected: false }
      ],
    },
    {
      id: "Diag15",
      title: "Diagnosis: <>P ⊢ [][]<>P",
      frame: "Find the strongest logic where this fails.",
      description: "Build a countermodel showing <>P does not entail [][]<>P. We report truth values but do not mark success.",
      diagnostic: true,
      constraints: [
        { type: "truth", world: 0, formula: "<>P", expected: true },
        { type: "truth", world: 0, formula: "[][]<>P", expected: false }
      ],
    },
    {
      id: "Diag16",
      title: "Diagnosis: <>[]P ⊢ []<>P",
      frame: "Find the strongest logic where this fails.",
      description: "Build a countermodel showing <>[]P does not entail []<>P. We report truth values but do not mark success.",
      diagnostic: true,
      constraints: [
        { type: "truth", world: 0, formula: "<>[]P", expected: true },
        { type: "truth", world: 0, formula: "[]<>P", expected: false }
      ],
    },
  ];

  let activeIndex = 0;

  function renderProblemList() {
    const list = document.getElementById("problem-list");
    list.innerHTML = "";
    problems.forEach((p, idx) => {
      const btn = document.createElement("button");
      btn.className = "problem-button" + (idx === activeIndex ? " active" : "");
      const solvedIcon = p.diagnostic ? "ℹ️" : (p.solved ? "✅" : "⬜");
      btn.innerHTML = `<span class="status">${solvedIcon}</span>${p.title}`;
      btn.onclick = () => setActiveProblem(idx);
      list.appendChild(btn);
    });
  }

  function setActiveProblem(idx) {
    activeIndex = idx;
    const p = problems[idx];
    document.getElementById("problem-title").textContent = p.title;
    document.getElementById("problem-description").textContent = p.description + (p.frame ? ` (Frame: ${p.frame})` : "");
    const ul = document.getElementById("constraint-list");
    ul.innerHTML = "";
    p.constraints.forEach(c => {
      const li = document.createElement("li");
      if (c.type === "relation") {
        const expectation = c.expected ? "should hold" : "should fail";
        li.textContent = `Accessibility ${c.property} ${expectation}.`;
      } else {
        li.textContent = `At w${(c.world || 0)}: ${c.formula} should be ${c.expected ? "true" : "false"}`;
      }
      ul.appendChild(li);
    });

    // push stored model string into iframe if present
    const frame = document.getElementById("playground-frame");
    if (frame && frame.contentWindow && p.modelString) {
      frame.contentWindow.location.href = `../kripke-worksheet/modallogic/index.html?model=${p.modelString}`;
    }

    renderProblemList();
  }

  function checkCurrentProblem() {
    const frame = document.getElementById("playground-frame");
    const win = frame.contentWindow;
    if (!win || !win.MPL || !win.model) {
      alert("Playground not ready yet — try again in a moment.");
      return;
    }

    const p = problems[activeIndex];
    const model = win.model;
    const MPL = win.MPL;
    p.modelString = model.getModelString();

    let allOk = true;
    const lines = [];

    const relationChecks = {
      reflexive: AccessibilityChecks.isReflexive,
      symmetric: AccessibilityChecks.isSymmetric,
      transitive: AccessibilityChecks.isTransitive,
    };

    for (const c of p.constraints) {
      if (c.type === "truth") {
        const wff = new MPL.Wff(c.formula);
        const val = MPL.truth(model, c.world, wff);
        const ok = val === c.expected;
        allOk = allOk && ok;
        lines.push(`At w${c.world}: ${c.formula} is ${val ? "T" : "F"} (expected ${c.expected ? "T" : "F"})`);
      } else if (c.type === "relation") {
        const checker = relationChecks[c.property];
        if (!checker) continue;
        const val = checker(model);
        const ok = val === c.expected;
        allOk = allOk && ok;
        const descriptor = c.property[0].toUpperCase() + c.property.slice(1);
        const status = val ? "holds" : "fails";
        lines.push(`Accessibility: ${descriptor} ${status} (expected ${c.expected ? "to hold" : "to fail"})`);
      }
    }

    if (!p.diagnostic) {
      p.solved = allOk;
    }

    renderProblemList();
    let out = lines.join("\n") + "\n\n";
    if (p.diagnostic) {
      out += "ℹ️ Diagnostic prompt: truth values and frame properties are reported but not graded.";
    } else if (allOk) {
      out += "✅ Meets the truth and accessibility constraints.";
    } else {
      out += "❌ Not yet — adjust your model and try again.";
    }
    document.getElementById("result").textContent = out;
  }

  window.addEventListener("load", () => {
    renderProblemList();
    setActiveProblem(0);
  });
</script>
</body>
</html>
